"use strict";

function qLog ( text ) {
  // only find fullJSON once
  if( typeof qLog.element == 'undefined' ) {
    qLog.element = $("#fullJSON");
  }
  qLog.element.text( qLog.element.text() + "\n - " + text );
}


// var parse_row = function ( pNum, ing, rowContent, prop ) {
var parse_row = function ( interRow, n, rowContent, props ) {
  if( interRow == -1 ) {
    console.debug( "skipped header row" );
    return;
  }

  var qText = $(rowContent).text().trim();
  // console.info( "qText = " + qText );

  if( interRow == 0 ) {
    switch( n ) {
      case 0: // images two rows high
        console.debug( "parsing first half" );
        console.debug( rowContent );
        break;

      case 1:
        props.name = $(rowContent).find("a").text().trim();
        console.debug( "Name = " + props.name );
        // could also extract ID from here
        break;

      case 2:
        props.source = qText;
        console.debug( "Source = " + props.source );
        break;

      default: console.error( "Parser Error : out of bounds error at " + props.name );
    }


  // }else{
  }else if( interRow == 1 ) {
    console.debug( "n = " + n + ":" + qText );
    switch( n ) {
      case 0: props.eff1 = qText; break;
      case 1: props.eff2 = qText; break;
      case 2: props.eff3 = qText; break;
      case 3: props.eff4 = qText; break;
      case 4: props.value = qText; break;
      case 5: props.weight = qText; break;
      case 6: props.planting = qText; break;
      default: console.info( "Unexpected Parser Field : out of bounds error at " + props.name );
    };
  }
  console.warn( props );
}

function parseIngFile( idx, fn ){
  return(
    $.ajax( {
      url: fn,
      dataType: 'text',
      success: function( doc ) {
        qLog( "loaded ingredients source data" );

        // source: http://stackoverflow.com/questions/15150264/jquery-how-to-stop-auto-load-imges-when-parsehtml
        var new_doc = doc.replace(/<img [^>]*src=['"]([^'"]+)[^>]*>/gi, function (match, capture) {return "<img no_load_src=\"" +capture+ "\" />";});
        var interRow = -1; // want to skip the first row -- it is headers
        var props = {};
        props.name = "";

        $( "tr", new_doc ).each( function() {
          var iterField = 0;

          $(this).find( "td" ).each( function() { parse_row( interRow, iterField++, this, props ); });

          if( ++interRow == 2 ) {
            interRow = 0;
            idx.ip.push( props );
            console.warn( props );
            props = {};
            props.name = "";
          }

        });
        qLog( "parsed ingredients data" );
      },
      error:function(jqXHR, textStatus, errorThrown){ alert(textStatus); }
    })
  );
}

$(document).ready(function(){
  var idx = {};
  idx.ip = [];
  idx.ii = {};
  idx.ep = [];
  idx.ei = {};


  // fullJSON.text( JSON.stringify( idx ));
  // source: http://stackoverflow.com/questions/3709597/wait-until-all-jquery-ajax-requests-are-done
  $.when(
    parseIngFile( idx, "source_data/simple_www.uesp.net_wiki_Skyrim_Ingredients.html" )
  ).done( function( p1 ){
    // indexIngData( idx );
    $("#fullJSON").text( "/* autogenerated content -- DO NOT MODIFY\n"
      + " * to change this data you must:\n"
      + " * 1. edit js/parser.js\n"
      + " * 2. load parser.html\n"
      + " * 3. paste the content into js/idx.js\n"
      + " */\n\n"
      + "function getIdx() { return( \n"
      + JSON.stringify( idx, null, ' ' )
      + "\n);}" );
  });
});


/*
$(document).ready(function(){
  var idx = getIdx();
  var ingList = $("#ingredients");
  $.each( idx.ip, function( index, value ) {
    ingList.append(
      "<li data-role=\"presentation\" data-idx="+index+">"
      + "<span class=\"label label-default\">"
      + value.name
      + "</span></li>" );
  });
});
*/
// vim: set ts=2 sw=2 et:
